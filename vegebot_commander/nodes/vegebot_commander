#!/usr/bin/env python

import rospy
from std_msgs.msg import String, Bool

import sys
import time
import copy
from copy import deepcopy
import moveit_commander
from moveit_commander import MoveGroupCommander, PlanningSceneInterface, RobotCommander
import moveit_msgs.msg
import geometry_msgs.msg
from ur_msgs.srv import SetIO

from moveit_msgs.msg import RobotTrajectory
from trajectory_msgs.msg import JointTrajectoryPoint
from geometry_msgs.msg import PoseStamped, Pose

#import ur_msgs

DISABLE_MOVEMENT = False
DISABLE_IO = True 

PICK_POSITION = [ 1.0, 0.0, 0.5]
PICK_ORIENTATION = [ 0.0, 0.707106781, 0.0, 0.707106781]

PARK_POSITION = [ 0.38309, -0.39763, 0.93282]
PARK_ORIENTATION = [ 0.0, 0.707106781, 0.0, 0.707106781]

#PLACE_POSITION = [ -0.3, 0.8, 1.2]
PLACE_POSITION = [ -0.2, -0.7, 0.93282]
PLACE_ORIENTATION = [ 0.0, 0.707106781, 0.0, 0.707106781]

SCAN_POSITION = [ 1.0, 0.0, 0.5]
SCAN_ORIENTATION= [ 0.0, 0.707106781, 0.0, 0.707106781]

END_EFFECTOR_TO_LETTUCE_Z = 0.14
#END_EFFECTOR_TO_LETTUCE_Z = 0.18
PREGRASP_OFFSET = [0.0, 0.0, 0.3]
TARGET_END_EFFECTOR_OFFSET = [0.0, 0.0, END_EFFECTOR_TO_LETTUCE_Z]

URF10_ORIGIN = [0.0, 0.0, 0.0]

MAX_PLANNING_ATTEMPTS = 10

UR10_DIGITAL_IO_OUT = 1
UR10_BLADE_PIN8 = 16
UR10_BLADE_PIN9 = 17

VELOCITY_SCALE = 0.75

Robot = 0
Scene = 0
Manipulator = 0
Display_trajectory_publisher = 0
Snapshot_publisher = 0

# MoveIt routines        

def pick_test(params):
    print("Picking test...")
    move_to(PICK_POSITION, PICK_ORIENTATION)  
    print("== Picked.")

def pick(params):
    print("Picking...")
    print params
    if (len(params)==4):
        x = float(params[1])
        y = float(params[2])
        z = float(params[3])
        position = [x, y, z]
        position = offset_end_effector_from_lettuce(position)
        #move_to(position, PICK_ORIENTATION)  
        lettuce_picked = do_pick(position)
        if (lettuce_picked):
            do_place()
    else:
        print("*** WARNING: Need 1+3 parameters ***")
        print("Received " + len(params))
    print("== Picked.")

def offset_end_effector_from_lettuce(position):
    position[2] = position[2] + END_EFFECTOR_TO_LETTUCE_Z
    return position

def park(params):
    print("== Parking...") 
    move_to(PARK_POSITION, PARK_ORIENTATION)  
    blade_cut()
    timer.sleep(5)
    blade_release()
    print("== Parked.")

def do_pick(position):
    pregrasp_position = add_vectors(position, PREGRASP_OFFSET)
    pregrasp_position = add_vectors(pregrasp_position, TARGET_END_EFFECTOR_OFFSET)
    target_position = add_vectors(position, TARGET_END_EFFECTOR_OFFSET)

    if (reach_to_pregrasp_position(pregrasp_position)):
        if (descend_on_lettuce(target_position)):
            blade_cut()
            rospy.sleep(2)
            ascend_from_lettuce(pregrasp_position)
            #return True

    #rospy.loginfo("**** Problem with picking...")
    # reach_to_pregrasp_position(pregrasp_position)
    # descend_on_lettuce(position)        
    # blade_cut()
    # rospy.sleep(2.0)
    # ascend_from_lettuce(pregrasp_position)

    print("== Detect if lettuce is in the bucket ==")
    return True

def reach_to_pregrasp_position(pregrasp_position):
    print("== Moving to pregrasp position...")
    return move_to(pregrasp_position, PICK_ORIENTATION)

CARTESIAN_APPROACH = True

def descend_on_lettuce(position):
    print("== Approach lettuce...")
    if (CARTESIAN_APPROACH):
        return cartesian_move_to(position, PICK_ORIENTATION)
    else:
        return move_to(position, PICK_ORIENTATION)

def ascend_from_lettuce(pregrasp_position):
    print("== Retreat from lettuce...")
    if (CARTESIAN_APPROACH):
        return cartesian_move_to(pregrasp_position, PICK_ORIENTATION)
    else:
        return move_to(pregrasp_position, PICK_ORIENTATION)

def do_place():
    print("== Moving end effector to place position...")
    move_to(PLACE_POSITION, PLACE_ORIENTATION)
    print("== Release lettuce...")
    blade_release()

def subtract_vectors(vector1, vector2):
    vector3 = [0.0, 0.0, 0.0]
    for i in range(0,len(vector1)):
        vector3[i] = vector1[i] - vector2[i]
    return vector3        

def add_vectors(vector1, vector2):
    vector3 = [0.0, 0.0, 0.0]
    for i in range(0,len(vector1)):
        vector3[i] = vector1[i] + vector2[i]
    return vector3        

def move_to(position, orientation):
    global Manipulator

    if DISABLE_MOVEMENT:
        rospy.sleep(3)
        return True

    print("Moving...")
    print "== Setting target"
    pose_target = new_pose(position, orientation)
    Manipulator.set_pose_target(pose_target)
    #print Robot.get_current_state()

    print("== Devising plan")
    attempts = 0
    trajectory = None
    while (attempts < MAX_PLANNING_ATTEMPTS):
        print "Planning attempt %s" % attempts
        trajectory = Manipulator.plan()
        #print trajectory
        if (plan_has_succeeded(trajectory)):
            break
        attempts = attempts + 1    
    if (not plan_has_succeeded(trajectory)):
        print("********* Could not find plan after %s attempts ********" % attempts)
        return False

    print("== Moving to target pose...")
    scaled_trajectory = scale_trajectory_speed(trajectory, VELOCITY_SCALE)
    #result = Manipulator.execute(trajectory)
    result = Manipulator.execute(scaled_trajectory)
    print("----------------------------")
    print result
    print("----------------------------")
    # This following get_current_state() call appears to be necessary to normalize 
    # joint angles
    workaround = Robot.get_current_state()
    rospy.loginfo("== Move complete!")
    return result
    # return True

def cartesian_move_to(position, orientation):
    global Manipulator

    if DISABLE_MOVEMENT:
        rospy.sleep(3)
        return True

    end_effector_link = Manipulator.get_end_effector_link()
    start_pose = Manipulator.get_current_pose(end_effector_link).pose
    end_pose = deepcopy(new_pose(position, orientation))
    waypoints=[]
    # Don-t add start point! 
    # http://answers.ros.org/question/253004/moveit-problem-error-trajectory-message-contains-waypoints-that-are-not-strictly-increasing-in-time/
    #waypoints.append(deepcopy(start_pose))
    waypoints.append(end_pose)

    fraction = 0.0
    max_tries = 100
    attempts = 0
    eef_step = 0.01
    jump_threshold = 0.0
    avoid_collisions = True
    while fraction < 1.0 and attempts < max_tries:
        (plan, fraction) = Manipulator.compute_cartesian_path(
                                        waypoints,
                                        eef_step,
                                        jump_threshold,
                                        avoid_collisions)
        attempts += 1
        if attempts % 100 == 0:
            rospy.loginfo("Still attempting cartesian after " + str(attempts) + " attempts...")
    if fraction==1.0:
        rospy.loginfo("******** Successfully found Carteian trajectory.")
        rospy.loginfo(start_pose.position)
        rospy.loginfo(end_pose.position)
        scaled_plan = scale_trajectory_speed(plan, VELOCITY_SCALE)
        Manipulator.execute(scaled_plan)
        #Manipulator.execute(plan)
        workaround = Robot.get_current_state()
        #rospy.sleep(2)
        rospy.loginfo("******** Successfully executed Carteian trajectory.")
        return True
    else:
        rospy.loginfo("Failed to find Cartesian trajectory after " + str(attempts) + " attempts...")
        return False

def plan_has_succeeded(trajectory):
    if (trajectory==None):
        return False
    if (len(trajectory.joint_trajectory.points)==0):
        return False
    return True        


def new_pose(position, orientation):
    pose_target = geometry_msgs.msg.Pose()
    pose_target.orientation.x = orientation[0] #0.0
    pose_target.orientation.y = orientation[1] # 0.0
    pose_target.orientation.z = orientation[2] # 0.0
    pose_target.orientation.w = orientation[3] # 1.0
    pose_target.position.x = position[0] + URF10_ORIGIN[0]
    pose_target.position.y = position[1] + URF10_ORIGIN[1]
    pose_target.position.z = position[2] + URF10_ORIGIN[2]
    return pose_target

def visualize_plan(plan):
    display_trajectory = moveit_msgs.msg.DisplayTrajectory()
    display_trajectory.trajectory_start = Robot.get_current_state()
    display_trajectory.trajectory.append(plan)
    Display_trajectory_publisher.publish(display_trajectory)

def start_moveit():
    global Robot, Scene, Manipulator, Display_trajectory_publisher

    print("== Setting up MoveIt!")
    moveit_commander.roscpp_initialize(sys.argv)
    Robot = RobotCommander() 
    print("== Getting Robot Groups")
    print(Robot.get_group_names())
    Scene = PlanningSceneInterface()
    Manipulator = MoveGroupCommander("manipulator")
    Manipulator.allow_replanning(True)
    Display_trajectory_publisher = rospy.Publisher(
                                    '/move_group/display_planned_path',
                                    moveit_msgs.msg.DisplayTrajectory,
                                    queue_size=10)
    #print "== Printing robot state"
    print Robot.get_current_state()

# End of MoveIt routines

# Miscellaneous commands

def detect(params):
    print("Detecting lettuces...")
    # This is a dummy snapshot
    take_snapshot()

def detect_image(params):
    print("Moving to camera position...")
    move_to(SCAN_POSITION, SCAN_ORIENTATION)  
    print("Generating fake image...")
    trigger_fake_image_snapshot()

def detect_camera(params):
    print("Moving to camera position...")
    move_to(SCAN_POSITION, SCAN_ORIENTATION)  
    print("Generating fake image...")
    trigger_camera_snapshot()

def trigger_fake_image_snapshot():
    print("Triggering fake image snapshot...")
    Snapshot_publisher.publish('fake_image')

def trigger_camera_snapshot():
    print("Triggering fake image snapshot...")
    Snapshot_publisher.publish('camera_image')

def take_snapshot():
    print("Taking snapshot...")
    Snapshot_publisher.publish('fake_lettuces')

def blade_cut():
    print("== ACTIVATING BLADE!!!")
    blade_IO(UR10_BLADE_PIN8, 0)
    blade_IO(UR10_BLADE_PIN9, 1)

def blade_release():    
    print("== RETRACTING BLADE!!!")
    blade_IO(UR10_BLADE_PIN8, 1)
    blade_IO(UR10_BLADE_PIN9, 0)

def blade_IO(pin, voltage_level):
    print("BladeIO Pin " + str(pin) + " to level " + str(voltage_level))
    if DISABLE_IO:
        return
    # https://github.com/ThomasTimm/ur_modern_driver/issues/61 
    io_msg = SetIO()
    io_msg.fun = UR10_DIGITAL_IO_OUT
    #io_msg.pin = UR10_BLADE_PIN
    io_msg.pin = pin
    io_msg.state = voltage_level    
    service_proxy = rospy.ServiceProxy('/ur_driver/set_io', SetIO)
    service_proxy(UR10_DIGITAL_IO_OUT, pin, voltage_level)

UR10_DIGITAL_SET_VOLTAGE=4
UR10_DIGITAL_IO_VOLTAGE=12

def set_blade_voltage():
    print("Setting voltage of digital IO")
    if DISABLE_IO:
        return
    io_msg = SetIO()
    io_msg.fun = UR10_DIGITAL_SET_VOLTAGE
    #io_msg.pin = UR10_BLADE_PIN
    #io_msg.pin = pin
    io_msg.state = UR10_DIGITAL_IO_VOLTAGE    
    service_proxy = rospy.ServiceProxy('/ur_driver/set_io', io_msg)
    service_proxy(4, 8, 12)

# Communications        
    
def listener():
    print("== Setting up listener...")
    # In ROS, nodes are uniquely named. If two nodes with the same
    # node are launched, the previous one is kicked off. The
    # anonymous=True flag means that rospy will choose a unique
    # name for our 'listener' node so that multiple listeners can
    # run simultaneously.
    rospy.init_node('vegebot_commander', anonymous=True)
    prepare_snapshot_publisher()
    rospy.Subscriber("vegebot_commands", String, callback)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

def callback(data):
    print
    rospy.loginfo(rospy.get_caller_id() + "I heard %s", data.data)
    params = data.data.split()
    if (params[0]=='pick_test'):
        pick_test(params)
    elif (params[0]=='park'):
        park(params)
    elif (params[0]=='pick'):
        pick(params) 
    elif (params[0]=='detect'):
        detect(params) 
    elif (params[0]=='detect_image'):
        detect_image(params) 
    elif (params[0]=='detect_camera'):
        detect_camera(params) 

def prepare_snapshot_publisher():
    global Snapshot_publisher 
    Snapshot_publisher = rospy.Publisher('/vegebot/lettuce_test/take_snapshot',
                                            String,
                                            queue_size=10)


def scale_trajectory_speed(traj, scale):
       # Create a new trajectory object
       new_traj = RobotTrajectory()
       
       # Initialize the new trajectory to be the same as the input trajectory
       new_traj.joint_trajectory = traj.joint_trajectory
       
       # Get the number of joints involved
       n_joints = len(traj.joint_trajectory.joint_names)
       
       # Get the number of points on the trajectory
       n_points = len(traj.joint_trajectory.points)
        
       # Store the trajectory points
       points = list(traj.joint_trajectory.points)
       
       # Cycle through all points and joints and scale the time from start,
       # as well as joint speed and acceleration
       for i in range(n_points):
           point = JointTrajectoryPoint()
           
           # The joint positions are not scaled so pull them out first
           point.positions = traj.joint_trajectory.points[i].positions

           # Next, scale the time_from_start for this point
           point.time_from_start = traj.joint_trajectory.points[i].time_from_start / scale
           
           # Get the joint velocities for this point
           point.velocities = list(traj.joint_trajectory.points[i].velocities)
           
           # Get the joint accelerations for this point
           point.accelerations = list(traj.joint_trajectory.points[i].accelerations)
           
           # Scale the velocity and acceleration for each joint at this point
           for j in range(n_joints):
               point.velocities[j] = point.velocities[j] * scale
               point.accelerations[j] = point.accelerations[j] * scale * scale
        
           # Store the scaled trajectory point
           points[i] = point

       # Assign the modified points to the new trajectory
       new_traj.joint_trajectory.points = points

       # Return the new trajecotry
       return new_traj
   
def set_trajectory_speed(traj, speed):
       # Create a new trajectory object
       new_traj = RobotTrajectory()
       
       # Initialize the new trajectory to be the same as the input trajectory
       new_traj.joint_trajectory = traj.joint_trajectory
       
       # Get the number of joints involved
       n_joints = len(traj.joint_trajectory.joint_names)
       
       # Get the number of points on the trajectory
       n_points = len(traj.joint_trajectory.points)
        
       # Store the trajectory points
       points = list(traj.joint_trajectory.points)
       
       # Cycle through all points and joints and scale the time from start,
       # as well as joint speed and acceleration
       for i in range(n_points):
           point = JointTrajectoryPoint()
           
           # The joint positions are not scaled so pull them out first
           point.positions = traj.joint_trajectory.points[i].positions

           # Next, scale the time_from_start for this point
           point.time_from_start = traj.joint_trajectory.points[i].time_from_start
           
           # Initialize the joint velocities for this point
           point.velocities = [speed] * n_joints
           
           # Get the joint accelerations for this point
           point.accelerations = [speed / 4.0] * n_joints
        
           # Store the scaled trajectory point
           points[i] = point

       # Assign the modified points to the new trajectory
       new_traj.joint_trajectory.points = points

       # Return the new trajecotry
       return new_traj

# Main Loop of module

if __name__ == '__main__':
    print("Vegebot_Commander is listening for commands.")
    set_blade_voltage()
    blade_cut()
    blade_release()
    start_moveit()

    listener()

