#!/usr/bin/env python

import rospy
from std_msgs.msg import String, Bool

import sys
import copy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg

PICK_POSITION = [ 1.0, 0.0, 0.2]
#PICK_POSITION = [ 1.3842, 0.25651, 0.56165]
PICK_ORIENTATION = [ 0.0, 0.707106781, 0.0, 0.707106781]
#PICK_ORIENTATION = [ 0.70711, 0.0, -0.70711, 0.0]

PARK_POSITION = [ 0.38309, -0.39763, 0.93282]
PARK_ORIENTATION = [ 0.0, 0.707106781, 0.0, 0.707106781]
#PARK_ORIENTATION = [ 0.70591, 0.703, -0.0010698, -0.0010667]

END_EFFECTOR_TO_LETTUCE_Z = 0.5

URF10_ORIGIN = [0.0, 0.0, 0.0]

Robot = 0
Scene = 0
Group = 0
Display_trajectory_publisher = 0
Snapshot_publisher = 0

# MoveIt routines        

def pick_test(params):
    print("Picking test...")
    move_to(PICK_POSITION, PICK_ORIENTATION)  
    print("== Picked.")

def pick(params):
    print("Picking...")
    print params
    if (len(params)==4):
        x = float(params[1])
        y = float(params[2])
        z = float(params[3])
        position = [x, y, z]
        position = offset_end_effector_from_lettuce(position)
        move_to(position, PICK_ORIENTATION)  
    else:
        print("*** WARNING: Need 1+3 parameters ***")
        print("Received " + len(params))
    print("== Picked.")

def offset_end_effector_from_lettuce(position):
    position[2] = position[2] + END_EFFECTOR_TO_LETTUCE_Z
    return position

def park(params):
    print("== Parking...") 
    move_to(PARK_POSITION, PARK_ORIENTATION)  
    print("== Parked.")

def move_to(position, orientation):
    print("Moving...")
    print "== Printing robot state"
    #print Robot.get_current_state()
    print "== Generating plan"
    pose_target = geometry_msgs.msg.Pose()
    pose_target.orientation.x = orientation[0] #0.0
    pose_target.orientation.y = orientation[1] # 0.0
    pose_target.orientation.z = orientation[2] # 0.0
    pose_target.orientation.w = orientation[3] # 1.0
    pose_target.position.x = position[0] + URF10_ORIGIN[0]
    pose_target.position.y = position[1] + URF10_ORIGIN[1]
    pose_target.position.z = position[2] + URF10_ORIGIN[2]
    print("== Setting plan")
    Group.set_pose_target(pose_target)
    #print Robot.get_current_state()
    plan1 = Group.plan()
    print "== Visualizing plan"
    display_trajectory = moveit_msgs.msg.DisplayTrajectory()
    display_trajectory.trajectory_start = Robot.get_current_state()
    display_trajectory.trajectory.append(plan1)
    Display_trajectory_publisher.publish(display_trajectory);
    print("== Moving to target pose...")
    Group.go(wait=True)
    # This following get_current_state() call appears to be necessary to normalize 
    # joint angles
    #print Robot.get_current_state()
    rospy.loginfo("== Move complete!")

def start_moveit():
    global Robot, Scene, Group, Display_trajectory_publisher

    print("== Setting up MoveIt!")
    moveit_commander.roscpp_initialize(sys.argv)
    #rospy.init_node('move_group_python_interface_tutorial', anonymous=True)    
    Robot = moveit_commander.RobotCommander() 
    print("== Getting Robot Groups")
    print(Robot.get_group_names())
    Scene = moveit_commander.PlanningSceneInterface()
    Group = moveit_commander.MoveGroupCommander("manipulator")
    Display_trajectory_publisher = rospy.Publisher(
                                    '/move_group/display_planned_path',
                                    moveit_msgs.msg.DisplayTrajectory,
                                    queue_size=10)
    #print "== Printing robot state"
    #print Robot.get_current_state()

# End of MoveIt routines

# Miscellaneous commands

def detect(params):
    print("Detecting lettuces...")
    # This is a dummy snapshot
    take_snapshot()
    # Determine snapshot

def take_snapshot():
    print("Taking snapshot...")
    Snapshot_publisher.publish(True)

# Communications        
    
def listener():
    print("== Setting up listener...")
    # In ROS, nodes are uniquely named. If two nodes with the same
    # node are launched, the previous one is kicked off. The
    # anonymous=True flag means that rospy will choose a unique
    # name for our 'listener' node so that multiple listeners can
    # run simultaneously.
    rospy.init_node('vegebot_commander', anonymous=True)
    prepare_snapshot_publisher()
    rospy.Subscriber("vegebot_commands", String, callback)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

def callback(data):
    print
    rospy.loginfo(rospy.get_caller_id() + "I heard %s", data.data)
    params = data.data.split()
    if (params[0]=='pick_test'):
        pick_test(params)
    elif (params[0]=='park'):
        park(params)
    elif (params[0]=='pick'):
        pick(params) 
    elif (params[0]=='detect'):
        detect(params) 

def prepare_snapshot_publisher():
    global Snapshot_publisher 
    Snapshot_publisher = rospy.Publisher('/vegebot/lettuce_test/take_snapshot',
                                            Bool,
                                            queue_size=10)

# Main Loop of module

if __name__ == '__main__':
    print("Vegebot_Commander is listening for commands.")
    start_moveit()

    listener()

