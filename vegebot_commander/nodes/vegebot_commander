#!/usr/bin/env python

import rospy
from std_msgs.msg import String, Bool

import sys
import time
import copy
from copy import deepcopy
import moveit_commander
from moveit_commander import MoveGroupCommander, PlanningSceneInterface, RobotCommander
import moveit_msgs.msg
import geometry_msgs.msg
from ur_msgs.srv import SetIO

from moveit_msgs.msg import RobotTrajectory
from trajectory_msgs.msg import JointTrajectoryPoint
from geometry_msgs.msg import PoseStamped, Pose

#import ur_msgs

VEGEBOT_SIMULATION_PARAM = "/vegebot/simulation"
VEGEBOT_STATUS_TOPIC = "/vegebot/status"
IS_A_SIMULATION = False
DISABLE_MOVEMENT = False
DISABLE_IO = True 

PICK_POSITION = [ 1.0, 0.0, 0.5]
PICK_ORIENTATION= [ 0.5, -0.5, -0.5, -0.5]
#PICK_ORIENTATION = [ 0.0, 0.707106781, 0.0, 0.707106781]

PARK_POSITION = [ 0.38309, -0.39763, 0.93282]
PARK_ORIENTATION = [ 0.0, 0.707106781, 0.0, 0.707106781]

#PLACE_POSITION = [ -0.3, 0.8, 1.2]
PLACE_POSITION = [ -0.2, -0.7, 0.93282]
PLACE_ORIENTATION = [ 0.0, 0.707106781, 0.0, 0.707106781]

SCAN_POSITION = [ 0.9, 0.0, 0.8]
#SCAN_ORIENTATION= [ 0.0, 0.707106781, 0.0, 0.707106781]
#SCAN_ORIENTATION= [ 0.499999999736182, -0.499999999736182, -0.499999999736182, -0.499999999736182 ]
SCAN_ORIENTATION= [ 0.5, -0.5, -0.5, -0.5]
SCAN_POSITION_PARAM = '/vegebot/scan_position'

END_EFFECTOR_TO_LETTUCE_Z = 0.14
#END_EFFECTOR_TO_LETTUCE_Z = 0.18
PREGRASP_OFFSET = [0.0, 0.0, 0.3]
TARGET_END_EFFECTOR_OFFSET = [0.0, 0.0, END_EFFECTOR_TO_LETTUCE_Z]

URF10_ORIGIN = [0.0, 0.0, 0.0]

MAX_PLANNING_ATTEMPTS = 10

UR10_DIGITAL_IO_OUT = 1
UR10_BLADE_PIN8 = 16
UR10_BLADE_PIN9 = 17

VELOCITY_SCALE = 0.75

Robot = 0
Scene = 0
Manipulator = 0
Display_trajectory_publisher = 0
Snapshot_publisher = 0
Next_action = None
Last_action = None
Current_reference_position = []
Status_publisher = None

# MoveIt routines        

def pick_test(params):
    print("Picking test...")
    move_to(PICK_POSITION, PICK_ORIENTATION)  
    print("== Picked.")

def action(params):
    global Next_action, Last_action
    Next_action = Last_action
    next_action(params)

def get_positions_from_params(params):
    position = get_position_from_params(params)
    pregrasp_position = add_vectors(position, PREGRASP_OFFSET)
    pregrasp_position = add_vectors(pregrasp_position, TARGET_END_EFFECTOR_OFFSET)
    target_position = add_vectors(position, TARGET_END_EFFECTOR_OFFSET)
    return (pregrasp_position, target_position)

def next_action(params):
    global Next_action, Last_action, Current_reference_position

    print("==== Next action triggered ====")   
    position = get_position_from_params(params)
    pregrasp_position = add_vectors(position, PREGRASP_OFFSET)
    pregrasp_position = add_vectors(pregrasp_position, TARGET_END_EFFECTOR_OFFSET)
    target_position = add_vectors(position, TARGET_END_EFFECTOR_OFFSET)
    if (position != None):
        if (Next_action==None) or (Current_reference_position != position):
            Next_action = 'pregrasp'
        Last_action = Next_action        
        if Next_action=='pregrasp':
            success, status_message, Next_action = action_pregrasp(pregrasp_position)
        elif Next_action=="down":
            success, status_message, Next_action = action_down(target_position)  
        elif Next_action=="cut":
            success, status_message, Next_action = action_cut()  
        elif Next_action=="up":
            success, status_message, Next_action = action_up(pregrasp_position)  
        elif Next_action=="place":
            success, status_message, Next_action = action_place()  
        elif Next_action=="release":
            success, status_message, Next_action = action_release()  
        publish_status_message(status_message)    
        Current_reference_position = position         
    else:
        rospy.loginfo("***** Bad position sent from UI *****")
        pospy.loginfo("Cancelling next action.")

def publish_status_message(message):
        rospy.loginfo(message)
        Status_publisher.publish(message)

def action_pregrasp(pregrasp_position):
    rospy.loginfo("Executing pregrasp...")
    if (reach_to_pregrasp_position(pregrasp_position)):
        return (True, "Pregrasp succeeded.", "down")
    else:
        return (False, "Pregrasp FAILED.", "pregrasp")

def action_down(target_position):
    rospy.loginfo("Executing down...")
    if (descend_on_lettuce(target_position)):
        return (True, "Down succeeded.", "cut")
    else:
        return (False, "Down FAILED.", "down")

def action_cut():
    rospy.loginfo("Executing cut...")
    if (blade_cut()):
        return (True, "Cut succeeded.", "up")
    else:
        return (False, "Cut FAILED.", "cut")

def action_up(pregrasp_position):
    rospy.loginfo("Executing up...")
    if (ascend_from_lettuce(pregrasp_position)):
        return (True, "Up succeeded.", "place")
    else:
        return (False, "Up FAILED.", "up")

def action_place():
    rospy.loginfo("Executing place...")
    if (move_to(PLACE_POSITION, PLACE_ORIENTATION)):
        return (True, "Place succeeded.", "release")
    else:
        return (False, "Place FAILED.", "place")

def action_release():
    rospy.loginfo("Executing release...")
    if (blade_release()):
        return (True, "Release succeeded.", "pregrasp")
    else:
        return (False, "Release FAILED.", "release")

def get_position_from_params(params):
    if (len(params)==4):
        x = float(params[1])
        y = float(params[2])
        z = float(params[3])
        position = [x, y, z]
        position = offset_end_effector_from_lettuce(position)
        return position
    else:
        return None

def pick(params):
    print("Picking...")
    print params
    if (len(params)==4):
        x = float(params[1])
        y = float(params[2])
        z = float(params[3])
        position = [x, y, z]
        position = offset_end_effector_from_lettuce(position)
        #move_to(position, PICK_ORIENTATION)  
        lettuce_picked = do_pick(position)
        if (lettuce_picked):
            do_place()
    else:
        print("*** WARNING: Need 1+3 parameters ***")
        print("Received " + len(params))
    print("== Picked.")

def offset_end_effector_from_lettuce(position):
    position[2] = position[2] + END_EFFECTOR_TO_LETTUCE_Z
    return position

def park(params):
    print("== Parking...") 
    move_to(PARK_POSITION, PARK_ORIENTATION)  
    #blade_cut()
    #timer.sleep(5)
    blade_release()
    print("== Parked.")

def do_pick(position):
    pregrasp_position = add_vectors(position, PREGRASP_OFFSET)
    pregrasp_position = add_vectors(pregrasp_position, TARGET_END_EFFECTOR_OFFSET)
    target_position = add_vectors(position, TARGET_END_EFFECTOR_OFFSET)

    if (reach_to_pregrasp_position(pregrasp_position)):
        if (descend_on_lettuce(target_position)):
            blade_cut()
            rospy.sleep(2)
            ascend_from_lettuce(pregrasp_position)
            #return True

    #rospy.loginfo("**** Problem with picking...")
    # reach_to_pregrasp_position(pregrasp_position)
    # descend_on_lettuce(position)        
    # blade_cut()
    # rospy.sleep(2.0)
    # ascend_from_lettuce(pregrasp_position)

    print("== Detect if lettuce is in the bucket ==")
    return True

def reach_to_pregrasp_position(pregrasp_position):
    print("== Moving to pregrasp position...")
    return move_to(pregrasp_position, PICK_ORIENTATION)

CARTESIAN_APPROACH = True

def descend_on_lettuce(position):
    print("== Approach lettuce...")
    if (CARTESIAN_APPROACH):
        return cartesian_move_to(position, PICK_ORIENTATION)
    else:
        return move_to(position, PICK_ORIENTATION)

def ascend_from_lettuce(pregrasp_position):
    print("== Retreat from lettuce...")
    if (CARTESIAN_APPROACH):
        return cartesian_move_to(pregrasp_position, PICK_ORIENTATION)
    else:
        return move_to(pregrasp_position, PICK_ORIENTATION)

def do_place():
    print("== Moving end effector to place position...")
    move_to(PLACE_POSITION, PLACE_ORIENTATION)
    print("== Release lettuce...")
    blade_release()

def subtract_vectors(vector1, vector2):
    vector3 = [0.0, 0.0, 0.0]
    for i in range(0,len(vector1)):
        vector3[i] = vector1[i] - vector2[i]
    return vector3        

def add_vectors(vector1, vector2):
    vector3 = [0.0, 0.0, 0.0]
    for i in range(0,len(vector1)):
        vector3[i] = vector1[i] + vector2[i]
    return vector3        

def move_to(position, orientation):
    global Manipulator

    if DISABLE_MOVEMENT:
        rospy.sleep(3)
        return True

    print("Moving...")
    print "== Setting target"
    pose_target = new_pose(position, orientation)
    Manipulator.set_pose_target(pose_target)
    #print Robot.get_current_state()

    print("== Devising plan")
    attempts = 0
    trajectory = None
    while (attempts < MAX_PLANNING_ATTEMPTS):
        print "Planning attempt %s" % attempts
        trajectory = Manipulator.plan()
        #print trajectory
        if (plan_has_succeeded(trajectory)):
            break
        attempts = attempts + 1    
    if (not plan_has_succeeded(trajectory)):
        print("********* Could not find plan after %s attempts ********" % attempts)
        return False

    print("== Moving to target pose...")
    scaled_trajectory = scale_trajectory_speed(trajectory, VELOCITY_SCALE)
    #result = Manipulator.execute(trajectory)
    result = Manipulator.execute(scaled_trajectory)
    print("----------------------------")
    print result
    print("----------------------------")
    # This following get_current_state() call appears to be necessary to normalize 
    # joint angles
    workaround = Robot.get_current_state()
    rospy.loginfo("== Move complete!")
    return result
    # return True

def cartesian_move_to(position, orientation):
    global Manipulator

    if DISABLE_MOVEMENT:
        rospy.sleep(3)
        return True

    end_effector_link = Manipulator.get_end_effector_link()
    start_pose = Manipulator.get_current_pose(end_effector_link).pose
    end_pose = deepcopy(new_pose(position, orientation))
    waypoints=[]
    # Don-t add start point! 
    # http://answers.ros.org/question/253004/moveit-problem-error-trajectory-message-contains-waypoints-that-are-not-strictly-increasing-in-time/
    #waypoints.append(deepcopy(start_pose))
    waypoints.append(end_pose)

    fraction = 0.0
    max_tries = 100
    attempts = 0
    eef_step = 0.01
    jump_threshold = 0.0
    avoid_collisions = True
    while fraction < 1.0 and attempts < max_tries:
        (plan, fraction) = Manipulator.compute_cartesian_path(
                                        waypoints,
                                        eef_step,
                                        jump_threshold,
                                        avoid_collisions)
        attempts += 1
        if attempts % 100 == 0:
            rospy.loginfo("Still attempting cartesian after " + str(attempts) + " attempts...")
    if fraction==1.0:
        rospy.loginfo("******** Successfully found Carteian trajectory.")
        rospy.loginfo(start_pose.position)
        rospy.loginfo(end_pose.position)
        scaled_plan = scale_trajectory_speed(plan, VELOCITY_SCALE)
        Manipulator.execute(scaled_plan)
        #Manipulator.execute(plan)
        workaround = Robot.get_current_state()
        #rospy.sleep(2)
        rospy.loginfo("******** Successfully executed Carteian trajectory.")
        return True
    else:
        rospy.loginfo("Failed to find Cartesian trajectory after " + str(attempts) + " attempts...")
        return False

def plan_has_succeeded(trajectory):
    if (trajectory==None):
        return False
    if (len(trajectory.joint_trajectory.points)==0):
        return False
    return True        


def new_pose(position, orientation):
    pose_target = geometry_msgs.msg.Pose()
    pose_target.orientation.x = orientation[0] #0.0
    pose_target.orientation.y = orientation[1] # 0.0
    pose_target.orientation.z = orientation[2] # 0.0
    pose_target.orientation.w = orientation[3] # 1.0
    pose_target.position.x = position[0] + URF10_ORIGIN[0]
    pose_target.position.y = position[1] + URF10_ORIGIN[1]
    pose_target.position.z = position[2] + URF10_ORIGIN[2]
    return pose_target

def visualize_plan(plan):
    display_trajectory = moveit_msgs.msg.DisplayTrajectory()
    display_trajectory.trajectory_start = Robot.get_current_state()
    display_trajectory.trajectory.append(plan)
    Display_trajectory_publisher.publish(display_trajectory)

def start_moveit():
    global Robot, Scene, Manipulator, Display_trajectory_publisher

    print("== Setting up MoveIt!")
    moveit_commander.roscpp_initialize(sys.argv)
    Robot = RobotCommander() 
    print("== Getting Robot Groups")
    print(Robot.get_group_names())
    Scene = PlanningSceneInterface()
    Manipulator = MoveGroupCommander("manipulator")
    Manipulator.allow_replanning(True)
    Display_trajectory_publisher = rospy.Publisher(
                                    '/move_group/display_planned_path',
                                    moveit_msgs.msg.DisplayTrajectory,
                                    queue_size=10)
    #print "== Printing robot state"
    print Robot.get_current_state()

# End of MoveIt routines

# Miscellaneous commands

def detect(params):
    print("Detecting lettuces...")
    # This is a dummy snapshot
    take_snapshot()

def detect_image(params):
    print("Moving to camera position...")
    move_to(SCAN_POSITION, SCAN_ORIENTATION)  
    print("Generating fake image...")
    trigger_fake_image_snapshot()

def detect_camera(params):
    print("Moving to camera position...")
    position, orientation = reload_scan_position()
    #move_to(SCAN_POSITION, SCAN_ORIENTATION)  
    move_to(position, orientation)  
    print("Generating fake image...")
    trigger_camera_snapshot()

def reload_scan_position():
    x = rospy.get_param(SCAN_POSITION_PARAM + '/x')
    y = rospy.get_param(SCAN_POSITION_PARAM + '/y')
    z = rospy.get_param(SCAN_POSITION_PARAM + '/z')
     
    return ([x, y, z], SCAN_ORIENTATION)    

def initialize_scan_position():
    rospy.set_param(SCAN_POSITION_PARAM + '/x', SCAN_POSITION[0])
    rospy.set_param(SCAN_POSITION_PARAM + '/y', SCAN_POSITION[1])
    rospy.set_param(SCAN_POSITION_PARAM + '/z', SCAN_POSITION[2])

def trigger_fake_image_snapshot():
    print("Triggering fake image snapshot...")
    Snapshot_publisher.publish('fake_image')

def trigger_camera_snapshot():
    print("Triggering fake image snapshot...")
    Snapshot_publisher.publish('camera_image')

def take_snapshot():
    print("Taking snapshot...")
    Snapshot_publisher.publish('fake_lettuces')

def blade_cut():
    print("== ACTIVATING BLADE!!!")
    blade_IO(UR10_BLADE_PIN8, 0)
    blade_IO(UR10_BLADE_PIN9, 1)
    return True

def blade_release():    
    print("== RETRACTING BLADE!!!")
    blade_IO(UR10_BLADE_PIN8, 1)
    blade_IO(UR10_BLADE_PIN9, 0)
    return True

def blade_IO(pin, voltage_level):
    print("BladeIO Pin " + str(pin) + " to level " + str(voltage_level))
    if DISABLE_IO:
        return
    # https://github.com/ThomasTimm/ur_modern_driver/issues/61 
    io_msg = SetIO()
    io_msg.fun = UR10_DIGITAL_IO_OUT
    #io_msg.pin = UR10_BLADE_PIN
    io_msg.pin = pin
    io_msg.state = voltage_level    
    service_proxy = rospy.ServiceProxy('/ur_driver/set_io', SetIO)
    service_proxy(UR10_DIGITAL_IO_OUT, pin, voltage_level)

UR10_DIGITAL_SET_VOLTAGE=4
UR10_DIGITAL_IO_VOLTAGE=12

def set_blade_voltage():
    print("Setting voltage of digital IO")
    if DISABLE_IO:
        return
    io_msg = SetIO()
    io_msg.fun = UR10_DIGITAL_SET_VOLTAGE
    #io_msg.pin = UR10_BLADE_PIN
    #io_msg.pin = pin
    io_msg.state = UR10_DIGITAL_IO_VOLTAGE    
    service_proxy = rospy.ServiceProxy('/ur_driver/set_io', io_msg)
    service_proxy(4, 8, 12)

# Communications   

def get_config():
    global IS_A_SIMULATION, DISABLE_MOVEMENT, DISABLE_IO

    IS_A_SIMULATION = rospy.get_param(VEGEBOT_SIMULATION_PARAM)   
    if (IS_A_SIMULATION):
        DISABLE_IO = True

def set_defaults():
    initialize_scan_position()        
    
def listener():
    print("== Setting up listener...")
    # In ROS, nodes are uniquely named. If two nodes with the same
    # node are launched, the previous one is kicked off. The
    # anonymous=True flag means that rospy will choose a unique
    # name for our 'listener' node so that multiple listeners can
    # run simultaneously.
    rospy.init_node('vegebot_commander', anonymous=True)
    prepare_snapshot_publisher()
    rospy.Subscriber("vegebot_commands", String, callback)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

def callback(data):
    print
    rospy.loginfo(rospy.get_caller_id() + "I heard %s", data.data)
    params = data.data.split()
    command = params[0]
    if (command=='pick_test'):
        pick_test(params)
    elif (command=='park'):
        park(params)
    elif (command=='pick'):
        pick(params) 
    elif (command=='detect'):
        detect(params) 
    elif (command=='detect_image'):
        detect_image(params) 
    elif (command=='detect_camera'):
        detect_camera(params) 
    elif (command=='next_action'):
        next_action(params) 
    elif (command=='action'):
        action(params) 
    elif (command=='pregrasp'):
        pregrasp_position, target_position = get_positions_from_params(params)
        action_pregrasp(pregrasp_position) 
    elif (command=='down'):
        pregrasp_position, target_position = get_positions_from_params(params)
        action_down(target_position) 
    elif (command=='cut'):
        action_cut() 
    elif (command=='up'):
        pregrasp_position, target_position = get_positions_from_params(params)
        action_up(pregrasp_position) 
    elif (command=='place'):
        action_place() 
    elif (command=='release'):
        action_release() 

def prepare_snapshot_publisher():
    global Snapshot_publisher 
    Snapshot_publisher = rospy.Publisher('/vegebot/lettuce_test/take_snapshot',
                                            String,
                                            queue_size=10)

def set_up_status_topic():
    global Status_publisher         
    Status_publisher = rospy.Publisher(VEGEBOT_STATUS_TOPIC, String, queue_size=10)

def scale_trajectory_speed(traj, scale):
       # Create a new trajectory object
       new_traj = RobotTrajectory()
       
       # Initialize the new trajectory to be the same as the input trajectory
       new_traj.joint_trajectory = traj.joint_trajectory
       
       # Get the number of joints involved
       n_joints = len(traj.joint_trajectory.joint_names)
       
       # Get the number of points on the trajectory
       n_points = len(traj.joint_trajectory.points)
        
       # Store the trajectory points
       points = list(traj.joint_trajectory.points)
       
       # Cycle through all points and joints and scale the time from start,
       # as well as joint speed and acceleration
       for i in range(n_points):
           point = JointTrajectoryPoint()
           
           # The joint positions are not scaled so pull them out first
           point.positions = traj.joint_trajectory.points[i].positions

           # Next, scale the time_from_start for this point
           point.time_from_start = traj.joint_trajectory.points[i].time_from_start / scale
           
           # Get the joint velocities for this point
           point.velocities = list(traj.joint_trajectory.points[i].velocities)
           
           # Get the joint accelerations for this point
           point.accelerations = list(traj.joint_trajectory.points[i].accelerations)
           
           # Scale the velocity and acceleration for each joint at this point
           for j in range(n_joints):
               point.velocities[j] = point.velocities[j] * scale
               point.accelerations[j] = point.accelerations[j] * scale * scale
        
           # Store the scaled trajectory point
           points[i] = point

       # Assign the modified points to the new trajectory
       new_traj.joint_trajectory.points = points

       # Return the new trajecotry
       return new_traj
   
def set_trajectory_speed(traj, speed):
       # Create a new trajectory object
       new_traj = RobotTrajectory()
       
       # Initialize the new trajectory to be the same as the input trajectory
       new_traj.joint_trajectory = traj.joint_trajectory
       
       # Get the number of joints involved
       n_joints = len(traj.joint_trajectory.joint_names)
       
       # Get the number of points on the trajectory
       n_points = len(traj.joint_trajectory.points)
        
       # Store the trajectory points
       points = list(traj.joint_trajectory.points)
       
       # Cycle through all points and joints and scale the time from start,
       # as well as joint speed and acceleration
       for i in range(n_points):
           point = JointTrajectoryPoint()
           
           # The joint positions are not scaled so pull them out first
           point.positions = traj.joint_trajectory.points[i].positions

           # Next, scale the time_from_start for this point
           point.time_from_start = traj.joint_trajectory.points[i].time_from_start
           
           # Initialize the joint velocities for this point
           point.velocities = [speed] * n_joints
           
           # Get the joint accelerations for this point
           point.accelerations = [speed / 4.0] * n_joints
        
           # Store the scaled trajectory point
           points[i] = point

       # Assign the modified points to the new trajectory
       new_traj.joint_trajectory.points = points

       # Return the new trajecotry
       return new_traj

# def list_parameters():
#     parameter_names = rospy.get_param_names()
#     filtered_parameter_names = [x for x in parameter_names if x[:9] == '/vegebot/']
#     print filtered_parameter_names
    


# Main Loop of module

if __name__ == '__main__':
    print("Vegebot_Commander is listening for commands.")
    get_config()
    set_defaults()
    set_up_status_topic()
    set_blade_voltage()
    blade_cut()
    blade_release()
    start_moveit()

    listener()

